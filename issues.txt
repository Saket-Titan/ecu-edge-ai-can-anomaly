1.ecu_engine
    a. nucleo_g474re.overlay(&pinctrl {
    fdcan1_rx_pb13: fdcan1_rx_pb13 {
        pinmux = <STM32_PINMUX('B', 11, AF9)>;
    };
    fdcan1_tx_pb12: fdcan1_tx_pb12 {
        pinmux = <STM32_PINMUX('B', 12, AF9)>;
    };
};

&fdcan1 {
    pinctrl-0 = <&fdcan1_rx_pb13 &fdcan1_tx_pb12>;
    pinctrl-names = "default";
    status = "okay";
    bus-speed = <500000>;
};

/ {
    chosen {
        zephyr,canbus = &fdcan1;
    };
};)
    b.CMakeLists.txt(cmake_minimum_required(VERSION 3.20.0)

find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})

project(ecu_engine)

target_Sources(app PRIVATE main.c)
)
    c.Main.c(#include <zephyr/kernel.h>
#include <zephyr/drivers/can.h>
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(ecu_engine, LOG_LEVEL_INF);

const struct device *can_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_canbus));

int main(void) 
{
  if(!device_is_ready(can_dev)){
  LOG_ERR("CAN device not ready");
  return -1;
}
LOG_INF("CAN device ready: %s", can_dev->name);
  
  int r = can_start(can_dev);
  LOG_INF("Engine ECU (G474RE) starting... %d", r);
  
  struct can_frame frame = {0}; // to avoid any wrong data exchange
  frame.flags = CAN_FRAME_IDE; // to ensure all the 29 bits is being sent 
  frame.id = 0x18F00400; // the first two bit is to set priority 6, the middle for PGN, and the last 2 bits for the source address of engine.
  
  frame.dlc=8; // the standard data length 
  
  frame.data[0] = 0xFF;
  frame.data[1] = 0xFF;
  frame.data[2] = 0xFF;
  frame.data[3] = 0xE0;
  frame.data[4] = 0x2E;
  frame.data[5] = 0xFF;
  frame.data[6] = 0xFF;
  frame.data[7] = 0xFF;
  
    while(1) {
    int ret = can_send(can_dev, &frame, K_FOREVER, NULL, NULL);
    if(ret == 0){
        LOG_INF("sent engine speed:1500 RPM");
      }
    else {
      LOG_ERR("send failed with error %d", ret);
      }
    
    k_sleep(K_SECONDS(1));
    
    }
    return 0;

}

)
    d.prj.conf(CONFIG_GPIO=y
CONFIG_CAN=y
CONFIG_CAN_FD_MODE=y
CONFIG_LOG=y
)
2.ecu_body
    a. nucleo_h723zg.overlay(&pinctrl {
    fdcan1_rx_pb8: fdcan1_rx_pb8 {
        pinmux = <STM32_PINMUX('B', 8, AF9)>;
    };
    fdcan1_tx_pb9: fdcan1_tx_pb9 {
        pinmux = <STM32_PINMUX('B', 9, AF9)>;
    };
};

&i2c1 {
    status = "disabled";
};

&fdcan1 {
    pinctrl-0 = <&fdcan1_rx_pb8 &fdcan1_tx_pb9>;
    pinctrl-names = "default";
    status = "okay";
    bus-speed = <500000>;
    bus-speed-data = <2000000>;
};

/ {
    chosen {
        zephyr,canbus = &fdcan1;
    };
};)
    b.CMakeLists.txt(cmake_minimum_required(VERSION 3.20.0)

find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})

project(ecu_body)

target_sources(app PRIVATE main.c))
    c.Main.c(#include <zephyr/kernel.h>
#include <zephyr/drivers/can.h>
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(ecu_body, LOG_LEVEL_INF);

const struct device *can_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_canbus));

void can_callback(const struct device *dev, struct can_frame *frame, void *user_data)
{
    LOG_INF("Rx: ID=0x%08x DLC=%d Data=[%02X %02X]",
              frame->id, frame->dlc, frame->data[0], frame->data[1]);
}

int main(void)
{   //Device check
    if(!device_is_ready(can_dev)){
  LOG_ERR("CAN device not ready");
  return -1;
}
  LOG_INF("CAN device ready: %s", can_dev->name);
    
    //starting the can 
    can_start(can_dev);
    
    struct can_filter filter = {
      .flags = CAN_FILTER_IDE ,
      .id = 0,
      .mask = 0
    };
    
    can_add_rx_filter(can_dev, &can_callback, NULL, &filter);
    
    LOG_INF("ecu_body (H723ZG) listening on CAN-FD...");
    
    while(1) {
      k_sleep(K_SECONDS(1));
    }
    return 0;
    
}


)
    d.prj.conf(CONFIG_GPIO=y
                CONFIG_CAN=y
                CONFIG_CAN_FD_MODE=y
                CONFIG_LOG=y
                )